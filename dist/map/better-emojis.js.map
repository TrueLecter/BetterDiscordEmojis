{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/constants.js",
    "src/emoji.js",
    "src/initializer.js",
    "src/lib/clusterize.js",
    "src/main.js",
    "src/picker.js",
    "src/server.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "module.exports.API_BASE = 'https://discordapp.com/api'\r\n\r\nfunction n (id) {\r\n  return webpackJsonp([], [], [id])\r\n}\r\n\r\n/* May be changed with discord updates */\r\nmodule.exports.EMOJI_PICKER_PATH = '#app-mount > div > div:nth-child(7)'\r\nmodule.exports.LOCAL_STORAGE_MODULE = n(1590)\r\nmodule.exports.EMOJI_STORAGE_MODULE = n(168).default\r\nmodule.exports.TRANSLATION_MODULE = n(3)\r\nmodule.exports.TOKEN_KEY = n(0).TOKEN_KEY\r\n/* May be changed with discord updates.END */\r\n\r\nmodule.exports.ELEMENT_SCROLLER_WRAP = '<div class=\"scroller-wrap\"><div class=\"scroller\"></div></div>'\r\n\r\nmodule.exports.ELEMENT_SEARCH_INPUT = '<input type=\"text\" placeholder=\"Find the perfect emoji\" value=\"\">'\r\n\r\nmodule.exports.ELEMENT_SERVER_EMOJI_LIST = '<span class=\"server-emojis\"><div class=\"category\">server.name</div></span>'\r\nmodule.exports.ELEMENT_SERVER_EMOJI_LIST_ROW = '<div class=\"row\"></div>'\r\nmodule.exports.ELEMENT_SERVER_EMOJI_LIST_ROW_ENTRY = '<div class=\"emoji-item\"></div>' // max 10 per row\r\n\r\nmodule.exports.REACTION_POPOUT_REGEX = /TOGGLE_REACTION_POPOUT_(\\d+)/\r\nmodule.exports.CURRENT_SELECTED_CHANNEL_REGEX = /.*\\/.+\\/(\\d+)/\r\nmodule.exports.IS_INBOX_REGEX = /\\/channels\\/@me\\/\\d+/\r\n",
    "const id = Symbol('id')\r\nconst name = Symbol('name')\r\nconst url = Symbol('url')\r\nconst managed = Symbol('managed')\r\nconst requireColons = Symbol('requireColons')\r\nconst roles = Symbol('roles')\r\n\r\nclass Emoji {\r\n  constructor (_id, _name, _managed = false, _requireColons = true, _roles = [], _url = `https://cdn.discordapp.com/emojis/${_id}.png`) {\r\n    this[id] = _id\r\n    this[name] = _name\r\n    this[url] = _url\r\n    this[managed] = _managed\r\n    this[requireColons] = _requireColons\r\n    this[roles] = _roles\r\n  }\r\n\r\n  get id () {\r\n    return this[id]\r\n  }\r\n\r\n  get name () {\r\n    return this[name]\r\n  }\r\n\r\n  get url () {\r\n    return this[url]\r\n  }\r\n\r\n  get isManaged () {\r\n    return this[managed]\r\n  }\r\n\r\n  get colonsRequired () {\r\n    return this[requireColons]\r\n  }\r\n\r\n  get roles () {\r\n    return this[roles]\r\n  }\r\n\r\n  get useName () {\r\n    return this.colonsRequired ? `:${this.name}:` : this.name\r\n  }\r\n\r\n  static fromRaw (emojiRaw) {\r\n    return new Emoji(emojiRaw.id, emojiRaw.name, emojiRaw.managed, emojiRaw.requireColons, emojiRaw.roles)\r\n  }\r\n}\r\n\r\nmodule.exports = Emoji\r\n",
    "const Server = require('./server.js')\r\nconst Emoji = require('./emoji.js')\r\nconst Constants = require('./constants.js')\r\nconst Picker = require('./picker.js')\r\n\r\nlet MY_ID = ''\r\n\r\nfunction getServers () {\r\n  return new Promise((resolve, reject) => {\r\n    $.ajax({\r\n      'async': true,\r\n      'url': `${Constants.API_BASE}/users/@me/guilds`,\r\n      'method': 'GET'\r\n    })\r\n    .then(res => resolve(res))\r\n    .fail(err => reject(err))\r\n  })\r\n}\r\n\r\nfunction getMyId () {\r\n  return new Promise((resolve, reject) => {\r\n    $.ajax({\r\n      'async': true,\r\n      'url': `${Constants.API_BASE}/users/@me`,\r\n      'method': 'GET'\r\n    })\r\n    .then(response => {\r\n      MY_ID = response.id\r\n    })\r\n    .then(res => resolve(res))\r\n    .fail(err => reject(err))\r\n  })\r\n}\r\n\r\nfunction parseServer (server) {\r\n  return new Promise((resolve, reject) => {\r\n    $.ajax({\r\n      'async': true,\r\n      'url': `${Constants.API_BASE}/guilds/${server.id}/members/${MY_ID}`,\r\n      'method': 'GET'\r\n    }).done(response => {\r\n      const myRoles = response.roles\r\n      $.ajax({\r\n        'async': true,\r\n        'url': `${Constants.API_BASE}/guilds/${server.id}`,\r\n        'method': 'GET'\r\n      }).done(response => {\r\n        // now we got detailed info about server. fill emoji and managed emojis.\r\n        // also set name\r\n        const srv = new Server(response.id, response.name, server.permissions)\r\n\r\n        response.emojis.forEach(emojiRaw => {\r\n          // get emoji required roles\r\n          const emoji = Emoji.fromRaw(emojiRaw)\r\n          const eR = emoji.roles\r\n\r\n          if (!eR.length) {\r\n            srv.addEmoji(emoji)\r\n            return\r\n          }\r\n\r\n          for (const r in eR) {\r\n            // we have required role\r\n            if (myRoles.includes(r)) {\r\n              srv.addEmoji(emoji)\r\n              break\r\n            }\r\n          }\r\n        })\r\n        resolve(srv)\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\nfunction parseServers (serversA) {\r\n  return Promise.all(serversA.map(srv => parseServer(srv)))\r\n}\r\n\r\nfunction loadStandartEmojis () {\r\n  let commonEmojis = []\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const translation = Constants.TRANSLATION_MODULE.Messages\r\n    const categories = Constants.EMOJI_STORAGE_MODULE.getCategories()\r\n    let commonEmojisSpansCacheSpan = $('<span></span>')\r\n\r\n    for (let category of categories) {\r\n      const tr = translation[`EMOJI_CATEGORY_${category.toUpperCase()}`]\r\n      const fakeServer = new Server(tr, tr, 0x00040000)\r\n\r\n      const emojis = Constants.EMOJI_STORAGE_MODULE.getByCategory(category)\r\n\r\n      for (let emoji of emojis) {\r\n        fakeServer.addEmoji(new Emoji(emoji.index, emoji.uniqueName, emoji.managed, emoji.allNamesString.includes(':'), [], emoji.defaultUrl))\r\n      }\r\n\r\n      commonEmojis.push(fakeServer)\r\n      commonEmojisSpansCacheSpan.append(Picker.buildServerSpan(fakeServer))\r\n    }\r\n\r\n    resolve({emojis: commonEmojis, spanCache: commonEmojisSpansCacheSpan.html()})\r\n  })\r\n}\r\n\r\nfunction doGetEmojis () {\r\n  const token = Constants.LOCAL_STORAGE_MODULE.impl.get(Constants.TOKEN_KEY)\r\n\r\n  $.ajaxSetup({\r\n    'crossDomain': true,\r\n    'headers': { 'authorization': token }\r\n  })\r\n\r\n  return getMyId()\r\n    .then(getServers)\r\n    .then(parseServers)\r\n    .then(loadStandartEmojis)\r\n    .catch(e => { console.error('Error initializing Better Emojis!\\nProbably modules order has been changed\\n', e) })\r\n}\r\n\r\nmodule.exports = doGetEmojis\r\n",
    "/*! Clusterize.js - v0.17.6 - 2017-03-05\r\n* http://NeXTs.github.com/Clusterize.js/\r\n* Copyright (c) 2015 Denis Lukov; Licensed GPLv3 */\r\n\r\n;(function (name, definition) {\r\n  if (typeof module !== 'undefined') module.exports = definition()\r\n  else if (typeof define === 'function' && typeof define.amd === 'object') define(definition)\r\n  else this[name] = definition()\r\n}('Clusterize', function () {\r\n  'use strict'\r\n\r\n  // detect ie9 and lower\r\n  // https://gist.github.com/padolsey/527683#comment-786682\r\n  var ie = (function () {\r\n      for (var v = 3,\r\n        el = document.createElement('b'),\r\n        all = el.all || [];\r\n         el.innerHTML = '<!--[if gt IE ' + (++v) + ']><i><![endif]-->',\r\n         all[0];\r\n       ) {}\r\n      return v > 4 ? v : document.documentMode\r\n    }()),\r\n    is_mac = navigator.platform.toLowerCase().indexOf('mac') + 1\r\n  var Clusterize = function (data) {\r\n    if (!(this instanceof Clusterize)) { return new Clusterize(data) }\r\n    var self = this\r\n\r\n    var defaults = {\r\n      rows_in_block: 50,\r\n      blocks_in_cluster: 4,\r\n      tag: null,\r\n      show_no_data_row: true,\r\n      no_data_class: 'clusterize-no-data',\r\n      no_data_text: 'No data',\r\n      keep_parity: true,\r\n      callbacks: {}\r\n    }\r\n\r\n    // public parameters\r\n    self.options = {}\r\n    var options = ['rows_in_block', 'blocks_in_cluster', 'show_no_data_row', 'no_data_class', 'no_data_text', 'keep_parity', 'tag', 'callbacks']\r\n    for (var i = 0, option; option = options[i]; i++) {\r\n      self.options[option] = typeof data[option] !== 'undefined' && data[option] != null\r\n        ? data[option]\r\n        : defaults[option]\r\n    }\r\n\r\n    var elems = ['scroll', 'content']\r\n    for (var i = 0, elem; elem = elems[i]; i++) {\r\n      self[elem + '_elem'] = data[elem + 'Id']\r\n        ? document.getElementById(data[elem + 'Id'])\r\n        : data[elem + 'Elem']\r\n      if (!self[elem + '_elem']) { throw new Error('Error! Could not find ' + elem + ' element') }\r\n    }\r\n\r\n    // tabindex forces the browser to keep focus on the scrolling list, fixes #11\r\n    if (!self.content_elem.hasAttribute('tabindex')) { self.content_elem.setAttribute('tabindex', 0) }\r\n\r\n    // private parameters\r\n    var rows = isArray(data.rows)\r\n        ? data.rows\r\n        : self.fetchMarkup(),\r\n      cache = {},\r\n      scroll_top = self.scroll_elem.scrollTop\r\n\r\n    // append initial data\r\n    self.insertToDOM(rows, cache)\r\n\r\n    // restore the scroll position\r\n    self.scroll_elem.scrollTop = scroll_top\r\n\r\n    // adding scroll handler\r\n    var last_cluster = false,\r\n      scroll_debounce = 0,\r\n      pointer_events_set = false,\r\n      scrollEv = function () {\r\n      // fixes scrolling issue on Mac #3\r\n        if (is_mac) {\r\n          if (!pointer_events_set) self.content_elem.style.pointerEvents = 'none'\r\n          pointer_events_set = true\r\n          clearTimeout(scroll_debounce)\r\n          scroll_debounce = setTimeout(function () {\r\n            self.content_elem.style.pointerEvents = 'auto'\r\n            pointer_events_set = false\r\n          }, 50)\r\n        }\r\n        if (last_cluster != (last_cluster = self.getClusterNum())) { self.insertToDOM(rows, cache) }\r\n        if (self.options.callbacks.scrollingProgress) { self.options.callbacks.scrollingProgress(self.getScrollProgress()) }\r\n      },\r\n      resize_debounce = 0,\r\n      resizeEv = function () {\r\n        clearTimeout(resize_debounce)\r\n        resize_debounce = setTimeout(self.refresh, 100)\r\n      }\r\n    on('scroll', self.scroll_elem, scrollEv)\r\n    on('resize', window, resizeEv)\r\n\r\n    // public methods\r\n    self.destroy = function (clean) {\r\n      off('scroll', self.scroll_elem, scrollEv)\r\n      off('resize', window, resizeEv)\r\n      self.html((clean ? self.generateEmptyRow() : rows).join(''))\r\n    }\r\n    self.refresh = function (force) {\r\n      if (self.getRowsHeight(rows) || force) self.update(rows)\r\n    }\r\n    self.update = function (new_rows) {\r\n      rows = isArray(new_rows)\r\n        ? new_rows\r\n        : []\r\n      var scroll_top = self.scroll_elem.scrollTop\r\n      // fixes #39\r\n      if (rows.length * self.options.item_height < scroll_top) {\r\n        self.scroll_elem.scrollTop = 0\r\n        last_cluster = 0\r\n      }\r\n      self.insertToDOM(rows, cache)\r\n      self.scroll_elem.scrollTop = scroll_top\r\n    }\r\n    self.clear = function () {\r\n      self.update([])\r\n    }\r\n    self.getRowsAmount = function () {\r\n      return rows.length\r\n    }\r\n    self.getScrollProgress = function () {\r\n      return this.options.scroll_top / (rows.length * this.options.item_height) * 100 || 0\r\n    }\r\n\r\n    var add = function (where, _new_rows) {\r\n      var new_rows = isArray(_new_rows)\r\n        ? _new_rows\r\n        : []\r\n      if (!new_rows.length) return\r\n      rows = where == 'append'\r\n        ? rows.concat(new_rows)\r\n        : new_rows.concat(rows)\r\n      self.insertToDOM(rows, cache)\r\n    }\r\n    self.append = function (rows) {\r\n      add('append', rows)\r\n    }\r\n    self.prepend = function (rows) {\r\n      add('prepend', rows)\r\n    }\r\n  }\r\n\r\n  Clusterize.prototype = {\r\n    constructor: Clusterize,\r\n    // fetch existing markup\r\n    fetchMarkup: function () {\r\n      var rows = [], rows_nodes = this.getChildNodes(this.content_elem)\r\n      while (rows_nodes.length) {\r\n        rows.push(rows_nodes.shift().outerHTML)\r\n      }\r\n      return rows\r\n    },\r\n    // get tag name, content tag name, tag height, calc cluster height\r\n    exploreEnvironment: function (rows, cache) {\r\n      var opts = this.options\r\n      opts.content_tag = this.content_elem.tagName.toLowerCase()\r\n      if (!rows.length) return\r\n      if (ie && ie <= 9 && !opts.tag) opts.tag = rows[0].match(/<([^>\\s/]*)/)[1].toLowerCase()\r\n      if (this.content_elem.children.length <= 1) cache.data = this.html(rows[0] + rows[0] + rows[0])\r\n      if (!opts.tag) opts.tag = this.content_elem.children[0].tagName.toLowerCase()\r\n      this.getRowsHeight(rows)\r\n    },\r\n    getRowsHeight: function (rows) {\r\n      var opts = this.options,\r\n        prev_item_height = opts.item_height\r\n      opts.cluster_height = 0\r\n      if (!rows.length) return\r\n      var nodes = this.content_elem.children\r\n      var node = nodes[Math.floor(nodes.length / 2)]\r\n      opts.item_height = node.offsetHeight\r\n      // consider table's border-spacing\r\n      if (opts.tag == 'tr' && getStyle('borderCollapse', this.content_elem) != 'collapse') { opts.item_height += parseInt(getStyle('borderSpacing', this.content_elem), 10) || 0 }\r\n      // consider margins (and margins collapsing)\r\n      if (opts.tag != 'tr') {\r\n        var marginTop = parseInt(getStyle('marginTop', node), 10) || 0\r\n        var marginBottom = parseInt(getStyle('marginBottom', node), 10) || 0\r\n        opts.item_height += Math.max(marginTop, marginBottom)\r\n      }\r\n      opts.block_height = opts.item_height * opts.rows_in_block\r\n      opts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block\r\n      opts.cluster_height = opts.blocks_in_cluster * opts.block_height\r\n      return prev_item_height != opts.item_height\r\n    },\r\n    // get current cluster number\r\n    getClusterNum: function () {\r\n      this.options.scroll_top = this.scroll_elem.scrollTop\r\n      return Math.floor(this.options.scroll_top / (this.options.cluster_height - this.options.block_height)) || 0\r\n    },\r\n    // generate empty row if no data provided\r\n    generateEmptyRow: function () {\r\n      var opts = this.options\r\n      if (!opts.tag || !opts.show_no_data_row) return []\r\n      var empty_row = document.createElement(opts.tag),\r\n        no_data_content = document.createTextNode(opts.no_data_text), td\r\n      empty_row.className = opts.no_data_class\r\n      if (opts.tag == 'tr') {\r\n        td = document.createElement('td')\r\n        // fixes #53\r\n        td.colSpan = 100\r\n        td.appendChild(no_data_content)\r\n      }\r\n      empty_row.appendChild(td || no_data_content)\r\n      return [empty_row.outerHTML]\r\n    },\r\n    // generate cluster for current scroll position\r\n    generate: function (rows, cluster_num) {\r\n      var opts = this.options,\r\n        rows_len = rows.length\r\n      if (rows_len < opts.rows_in_block) {\r\n        return {\r\n          top_offset: 0,\r\n          bottom_offset: 0,\r\n          rows_above: 0,\r\n          rows: rows_len ? rows : this.generateEmptyRow()\r\n        }\r\n      }\r\n      var items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * cluster_num, 0),\r\n        items_end = items_start + opts.rows_in_cluster,\r\n        top_offset = Math.max(items_start * opts.item_height, 0),\r\n        bottom_offset = Math.max((rows_len - items_end) * opts.item_height, 0),\r\n        this_cluster_rows = [],\r\n        rows_above = items_start\r\n      if (top_offset < 1) {\r\n        rows_above++\r\n      }\r\n      for (var i = items_start; i < items_end; i++) {\r\n        rows[i] && this_cluster_rows.push(rows[i])\r\n      }\r\n      return {\r\n        top_offset: top_offset,\r\n        bottom_offset: bottom_offset,\r\n        rows_above: rows_above,\r\n        rows: this_cluster_rows\r\n      }\r\n    },\r\n    renderExtraTag: function (class_name, height) {\r\n      var tag = document.createElement(this.options.tag),\r\n        clusterize_prefix = 'clusterize-'\r\n      tag.className = [clusterize_prefix + 'extra-row', clusterize_prefix + class_name].join(' ')\r\n      height && (tag.style.height = height + 'px')\r\n      return tag.outerHTML\r\n    },\r\n    // if necessary verify data changed and insert to DOM\r\n    insertToDOM: function (rows, cache) {\r\n      // explore row's height\r\n      if (!this.options.cluster_height) {\r\n        this.exploreEnvironment(rows, cache)\r\n      }\r\n      var data = this.generate(rows, this.getClusterNum()),\r\n        this_cluster_rows = data.rows.join(''),\r\n        this_cluster_content_changed = this.checkChanges('data', this_cluster_rows, cache),\r\n        top_offset_changed = this.checkChanges('top', data.top_offset, cache),\r\n        only_bottom_offset_changed = this.checkChanges('bottom', data.bottom_offset, cache),\r\n        callbacks = this.options.callbacks,\r\n        layout = []\r\n\r\n      if (this_cluster_content_changed || top_offset_changed) {\r\n        if (data.top_offset) {\r\n          this.options.keep_parity && layout.push(this.renderExtraTag('keep-parity'))\r\n          layout.push(this.renderExtraTag('top-space', data.top_offset))\r\n        }\r\n        layout.push(this_cluster_rows)\r\n        data.bottom_offset && layout.push(this.renderExtraTag('bottom-space', data.bottom_offset))\r\n        callbacks.clusterWillChange && callbacks.clusterWillChange()\r\n        this.html(layout.join(''))\r\n        this.options.content_tag == 'ol' && this.content_elem.setAttribute('start', data.rows_above)\r\n        callbacks.clusterChanged && callbacks.clusterChanged()\r\n      } else if (only_bottom_offset_changed) {\r\n        this.content_elem.lastChild.style.height = data.bottom_offset + 'px'\r\n      }\r\n    },\r\n    // unfortunately ie <= 9 does not allow to use innerHTML for table elements, so make a workaround\r\n    html: function (data) {\r\n      var content_elem = this.content_elem\r\n      if (ie && ie <= 9 && this.options.tag == 'tr') {\r\n        var div = document.createElement('div'), last\r\n        div.innerHTML = '<table><tbody>' + data + '</tbody></table>'\r\n        while ((last = content_elem.lastChild)) {\r\n          content_elem.removeChild(last)\r\n        }\r\n        var rows_nodes = this.getChildNodes(div.firstChild.firstChild)\r\n        while (rows_nodes.length) {\r\n          content_elem.appendChild(rows_nodes.shift())\r\n        }\r\n      } else {\r\n        content_elem.innerHTML = data\r\n      }\r\n    },\r\n    getChildNodes: function (tag) {\r\n      var child_nodes = tag.children, nodes = []\r\n      for (var i = 0, ii = child_nodes.length; i < ii; i++) {\r\n        nodes.push(child_nodes[i])\r\n      }\r\n      return nodes\r\n    },\r\n    checkChanges: function (type, value, cache) {\r\n      var changed = value != cache[type]\r\n      cache[type] = value\r\n      return changed\r\n    }\r\n  }\r\n\r\n  // support functions\r\n  function on (evt, element, fnc) {\r\n    return element.addEventListener ? element.addEventListener(evt, fnc, false) : element.attachEvent('on' + evt, fnc)\r\n  }\r\n  function off (evt, element, fnc) {\r\n    return element.removeEventListener ? element.removeEventListener(evt, fnc, false) : element.detachEvent('on' + evt, fnc)\r\n  }\r\n  function isArray (arr) {\r\n    return Object.prototype.toString.call(arr) === '[object Array]'\r\n  }\r\n  function getStyle (prop, elem) {\r\n    return window.getComputedStyle ? window.getComputedStyle(elem)[prop] : elem.currentStyle[prop]\r\n  }\r\n\r\n  return Clusterize\r\n}))\r\n",
    "const Constants = require('./constants.js')\r\nconst Picker = require('./picker.js')\r\n\r\nconst initEmojis = require('./initializer.js')\r\n\r\nfunction watchForEmojiPickerChange (listener) {\r\n  const observer = new MutationObserver(mutations => {\r\n    if (typeof listener === 'function') {\r\n      listener(mutations)\r\n    }\r\n  })\r\n  observer.observe($(Constants.EMOJI_PICKER_PATH)[0], { childList: true })\r\n  return observer\r\n}\r\n\r\ninitEmojis().then((spanCache) => {\r\n  Picker.setCommonEmojiSpanCache(spanCache)\r\n  console.log('Better Emojis initialized')\r\n  setTimeout(() => {\r\n    window.better_emojis.observer = watchForEmojiPickerChange(([mutation]) => {\r\n      if (mutation.type === 'childList') {\r\n        if (mutation.addedNodes.length > 0) {\r\n          if ($(Constants.EMOJI_PICKER_PATH).find('.emoji-picker').length &&\r\n                    ($('.channel-textarea-emoji').hasClass('popout-open') || $('.btn-reaction.popout-open').length)) {\r\n            Picker.show()\r\n          }\r\n        }\r\n        if (mutation.removedNodes.length) {\r\n          if (window.better_emojis.current_cluster) {\r\n            window.better_emojis.current_cluster.destroy()\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }, 2000)\r\n})\r\n",
    "const Constants = require('./constants.js')\r\nconst Clusterize = require('./lib/clusterize.js')\r\nconst Server = require('./server.js')\r\n\r\nlet commonEmojisSpansCache = ''\r\nlet currentPickerEmojiRegistry = []\r\n\r\nlet SCROLLER_WRAP = null\r\nlet SCROLLER_WRAP_OLD = null\r\nlet SEARCH_INPUT = null\r\n\r\nfunction buildScrollerWrap () {\r\n  const s = SCROLLER_WRAP || $(Constants.ELEMENT_SCROLLER_WRAP)\r\n  const scr = s.find('.scroller')\r\n\r\n  scr.html(' ').off('click').off('mouseenter').off('mouseleave')\r\n  currentPickerEmojiRegistry.length = 0\r\n\r\n  const c = Server.getCurrentServer()\r\n    // Append all current server emojis, if any\r\n  if (c.emojis.length > 0) { scr.append(buildServerSpan(c)) }\r\n\r\n    // Append all other server shared emojis\r\n  if (c.canUseExternalEmojis) {\r\n    for (const server of Server.getAllServers()) {\r\n      if (!server.isCurrent() && server.sharedEmojis.length > 0) {\r\n        scr.append(buildServerSpan(server))\r\n      }\r\n    }\r\n  }\r\n\r\n    // Append common emojis\r\n  if (commonEmojisSpansCache) {\r\n    scr.append(commonEmojisSpansCache)\r\n  }\r\n\r\n  window.better_emojis.current_cluster = new Clusterize({\r\n    rows_in_block: 10,\r\n    blocks_in_cluster: 3,\r\n    scrollElem: scr[0],\r\n    contentElem: scr[0]\r\n  })\r\n\r\n  const emojiClickHandler = $('.channel-textarea-emoji').hasClass('popout-open') ? putEmojiInTextarea : addCurrentMessageReaction\r\n\r\n  scr\r\n    .on('click', '.emoji-item', e => { console.log('Selected emoji - ', currentPickerEmojiRegistry[$(e.target).attr('data-emoji')]) })\r\n    .on('click', '.emoji-item', e => { emojiClickHandler(currentPickerEmojiRegistry[$(e.target).attr('data-emoji')]) })\r\n    .on('mouseenter', '.emoji-item', e => {\r\n      $(e.target).addClass('selected')\r\n      if (SEARCH_INPUT) {\r\n        SEARCH_INPUT.attr('placeholder', currentPickerEmojiRegistry[$(e.target).attr('data-emoji')].useName)\r\n      }\r\n    })\r\n    .on('mouseleave', '.emoji-item', e => {\r\n      $(e.target).removeClass('selected')\r\n      if (SEARCH_INPUT) {\r\n        SEARCH_INPUT.attr('placeholder', 'Find the perfect emoji')\r\n      }\r\n    })\r\n\r\n  return s\r\n}\r\n\r\nfunction buildServerSpan (server) {\r\n  const s = $(Constants.ELEMENT_SERVER_EMOJI_LIST)\r\n  s.find('.category').html(server.name)\r\n\r\n  s.append(buildEmojisRows(server.availableEmojis()))\r\n\r\n  return s.html()\r\n}\r\n\r\nfunction buildEmojisRows (eL) {\r\n  const s = $('<span class=\"tl-emoji-list\"></span>')\r\n  let r = $(Constants.ELEMENT_SERVER_EMOJI_LIST_ROW)\r\n\r\n  const emojiElement = function (emoji) {\r\n    return $(Constants.ELEMENT_SERVER_EMOJI_LIST_ROW_ENTRY)\r\n            .css('background-image', `url(\"${emoji.url}\")`)\r\n            .attr('data-emoji', `${currentPickerEmojiRegistry.push(emoji) - 1}`)\r\n  }\r\n\r\n  for (let i = 0; i < eL.length; i++) {\r\n    if ((i !== 0) && (i % 10 === 0)) {\r\n      s.append(r)\r\n      r = $(Constants.ELEMENT_SERVER_EMOJI_LIST_ROW)\r\n    }\r\n    r.append(emojiElement(eL[i]))\r\n  }\r\n  s.append(r)\r\n\r\n  return s.html()\r\n}\r\n\r\nfunction putEmojiInTextarea (emoji) {\r\n  const textarea = $('.channel-textarea >> textarea')\r\n  textarea.val(`${textarea.val() + emoji.useName} `)\r\n}\r\n\r\nfunction findReact (dom) {\r\n  for (const key in dom) {\r\n    if (key.startsWith('__reactInternalInstance$')) {\r\n      return dom[key]\r\n    }\r\n  }\r\n  return null\r\n};\r\n\r\nfunction getSelectedMessageId () {\r\n  try {\r\n    return Constants.REACTION_POPOUT_REGEX.exec(\r\n            findReact($('.btn-reaction.popout-open').parent().get(0))\r\n            ._currentElement.props.children\r\n            .filter(c => {\r\n              return Object.keys(c.props).includes('subscribeTo')\r\n            })[0].props.subscribeTo)[1]\r\n  } catch (e) {\r\n    return null\r\n  }\r\n}\r\n\r\nfunction getCurrentSelectedChannel () {\r\n  return Constants.CURRENT_SELECTED_CHANNEL_REGEX.exec(window.location.pathname)[1]\r\n}\r\n\r\nfunction addCurrentMessageReaction (emoji) {\r\n  return addMessageReaction(getCurrentSelectedChannel(), getSelectedMessageId(), emoji)\r\n}\r\n\r\nfunction addMessageReaction (channel, message, emoji) {\r\n  $.ajax(`${Constants.API_BASE}/channels/${channel}/messages/${message}/reactions/:${emoji.name}:${emoji.id}/@me`, { method: 'PUT' })\r\n}\r\n\r\nfunction showOriginalScroller () {\r\n  SCROLLER_WRAP.hide()\r\n  SCROLLER_WRAP_OLD.show()\r\n}\r\n\r\nfunction showCustomScroller () {\r\n  SCROLLER_WRAP.show()\r\n  SCROLLER_WRAP_OLD.hide()\r\n  SCROLLER_WRAP.find('.scroller').scrollTop(0)\r\n}\r\n\r\nfunction replaceScroller () {\r\n  SCROLLER_WRAP = buildScrollerWrap()\r\n  SCROLLER_WRAP_OLD = $(Constants.EMOJI_PICKER_PATH).find('.scroller-wrap')\r\n  SCROLLER_WRAP_OLD.hide().before(SCROLLER_WRAP)\r\n}\r\n\r\nfunction replaceSearchInput () {\r\n  // SEARCH_INPUT = buildSearchInput();\r\n  // $(EMOJI_PICKER_PATH).find(\"input\").hide().before(SEARCH_INPUT);\r\n  // Temporary disabled, as original search have much better performance\r\n  SEARCH_INPUT = $(Constants.EMOJI_PICKER_PATH).find('input')\r\n  SEARCH_INPUT.change((e) => {\r\n    if (!$(e.target).val()) {\r\n      showCustomScroller()\r\n    } else {\r\n      showOriginalScroller()\r\n    }\r\n  })\r\n}\r\n\r\nfunction addCustomScrollerParts () {\r\n    // console.log(\"picker opened\");\r\n  setTimeout(replaceScroller, 20)\r\n  setTimeout(replaceSearchInput, 20)\r\n  setTimeout(() => {\r\n    const categories = $(Constants.EMOJI_PICKER_PATH).find('.categories')\r\n    const categoriesChildren = categories.children()\r\n    const customScroller = ['recent', 'custom']\r\n\r\n    categories.on('click', '.item', function (event) {\r\n      const $this = $(this)\r\n\r\n      categoriesChildren.removeClass('selected')\r\n      $this.addClass('selected')\r\n\r\n      customScroller.forEach(function (category) {\r\n        if ($this.hasClass(category)) {\r\n          showCustomScroller.call(this, event)\r\n        }\r\n      })\r\n\r\n      showOriginalScroller.call(this, event)\r\n    })\r\n  }, 20)\r\n  setTimeout(showCustomScroller, 30)\r\n}\r\n\r\nmodule.exports.buildServerSpan = buildServerSpan\r\nmodule.exports.show = addCustomScrollerParts\r\n\r\nmodule.exports.setCommonEmojiSpanCache = function (cache) {\r\n  commonEmojisSpansCache = cache\r\n}\r\n",
    "const Emoji = require('./emoji.js')\r\n\r\nconst GLOBAL_SERVER_LIST = []\r\n\r\nconst id = Symbol('id')\r\nconst name = Symbol('name')\r\nconst emojis = Symbol('emojis')\r\nconst sharedEmojis = Symbol('sharedEmojis')\r\nconst permissions = Symbol('permissions')\r\nconst serverRegex = Symbol('serverRegex')\r\n\r\nclass Server {\r\n  constructor (_id, _name, _permissions, _emojis = [], _sharedEmojis = []) {\r\n    if (GLOBAL_SERVER_LIST.some(s => s.id === _id)) {\r\n      throw new Error('Cannot have multiple servers with same id!')\r\n    }\r\n\r\n    this[id] = _id\r\n    this[name] = _name\r\n    this[permissions] = _permissions\r\n    this[emojis] = _emojis\r\n    this[sharedEmojis] = _sharedEmojis\r\n    this[serverRegex] = new RegExp(`.*/${_id.toString()}/\\\\d+`)\r\n\r\n    GLOBAL_SERVER_LIST.push(this)\r\n  }\r\n\r\n  addEmoji (emoji) {\r\n    if (!(emoji instanceof Emoji)) {\r\n      throw new TypeError('Only objects of class Emoji can be added using this method')\r\n    }\r\n\r\n    if (this[emojis].some(e => e.id === emoji.id)) {\r\n      return\r\n    }\r\n\r\n    this[emojis].push(emoji)\r\n\r\n    if (emoji.isManaged) {\r\n      this[sharedEmojis].push(emoji)\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  get canUseExternalEmojis () {\r\n    return this[permissions] & 0x00040000\r\n  }\r\n\r\n  get id () {\r\n    return this[id]\r\n  }\r\n\r\n  get name () {\r\n    return this[name]\r\n  }\r\n\r\n  get permissions () {\r\n    return this[permissions]\r\n  }\r\n\r\n  get emojis () {\r\n    return this[emojis]\r\n  }\r\n\r\n  get sharedEmojis () {\r\n    return this[sharedEmojis]\r\n  }\r\n\r\n  isCurrent () {\r\n    return this[serverRegex].test(window.location)\r\n  }\r\n\r\n  availableEmojis () {\r\n    return this.isCurrent() ? this.emojis : this.sharedEmojis\r\n  }\r\n\r\n  possibleEmojis () {\r\n    const list = this.emojis\r\n\r\n    for (const server of GLOBAL_SERVER_LIST) {\r\n      if (server.id === this.id) {\r\n        continue\r\n      }\r\n\r\n      list.push(...server.sharedEmojis)\r\n    }\r\n\r\n    return list\r\n  }\r\n\r\n  static getCurrentServer () {\r\n    return GLOBAL_SERVER_LIST.reduce((p, c) => (p || (c.isCurrent() && c)), false) || null\r\n  }\r\n\r\n  static getAllServers () {\r\n    return GLOBAL_SERVER_LIST\r\n  }\r\n\r\n  static getById (id) {\r\n    return GLOBAL_SERVER_LIST.reduce((p, c) => (p || ((c.id === id) && c)), false) || null\r\n  }\r\n}\r\n\r\n// Store \"inbox\" emulation of server\r\nnew Server('@me', '@me', 0x00040000) // eslint-disable-line no-new\r\n\r\nmodule.exports = Server\r\n"
  ]
}